// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fakerepository

import (
	"homework/domain/model/room"
	"homework/domain/repository"
	"sync"
)

// Ensure, that IRoomRepositoryMock does implement repository.IRoomRepository.
// If this is not the case, regenerate this file with moq.
var _ repository.IRoomRepository = &IRoomRepositoryMock{}

// IRoomRepositoryMock is a mock implementation of repository.IRoomRepository.
//
//	func TestSomethingThatUsesIRoomRepository(t *testing.T) {
//
//		// make and configure a mocked repository.IRoomRepository
//		mockedIRoomRepository := &IRoomRepositoryMock{
//			CreateFunc: func(db repository.DBConn) (string, error) {
//				panic("mock out the Create method")
//			},
//			CreateMapFunc: func(db repository.DBConn, roomMap room.RoomMap) error {
//				panic("mock out the CreateMap method")
//			},
//		}
//
//		// use mockedIRoomRepository in code that requires repository.IRoomRepository
//		// and then make assertions.
//
//	}
type IRoomRepositoryMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(db repository.DBConn) (string, error)

	// CreateMapFunc mocks the CreateMap method.
	CreateMapFunc func(db repository.DBConn, roomMap room.RoomMap) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Db is the db argument value.
			Db repository.DBConn
		}
		// CreateMap holds details about calls to the CreateMap method.
		CreateMap []struct {
			// Db is the db argument value.
			Db repository.DBConn
			// RoomMap is the roomMap argument value.
			RoomMap room.RoomMap
		}
	}
	lockCreate    sync.RWMutex
	lockCreateMap sync.RWMutex
}

// Create calls CreateFunc.
func (mock *IRoomRepositoryMock) Create(db repository.DBConn) (string, error) {
	if mock.CreateFunc == nil {
		panic("IRoomRepositoryMock.CreateFunc: method is nil but IRoomRepository.Create was just called")
	}
	callInfo := struct {
		Db repository.DBConn
	}{
		Db: db,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(db)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedIRoomRepository.CreateCalls())
func (mock *IRoomRepositoryMock) CreateCalls() []struct {
	Db repository.DBConn
} {
	var calls []struct {
		Db repository.DBConn
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// CreateMap calls CreateMapFunc.
func (mock *IRoomRepositoryMock) CreateMap(db repository.DBConn, roomMap room.RoomMap) error {
	if mock.CreateMapFunc == nil {
		panic("IRoomRepositoryMock.CreateMapFunc: method is nil but IRoomRepository.CreateMap was just called")
	}
	callInfo := struct {
		Db      repository.DBConn
		RoomMap room.RoomMap
	}{
		Db:      db,
		RoomMap: roomMap,
	}
	mock.lockCreateMap.Lock()
	mock.calls.CreateMap = append(mock.calls.CreateMap, callInfo)
	mock.lockCreateMap.Unlock()
	return mock.CreateMapFunc(db, roomMap)
}

// CreateMapCalls gets all the calls that were made to CreateMap.
// Check the length with:
//
//	len(mockedIRoomRepository.CreateMapCalls())
func (mock *IRoomRepositoryMock) CreateMapCalls() []struct {
	Db      repository.DBConn
	RoomMap room.RoomMap
} {
	var calls []struct {
		Db      repository.DBConn
		RoomMap room.RoomMap
	}
	mock.lockCreateMap.RLock()
	calls = mock.calls.CreateMap
	mock.lockCreateMap.RUnlock()
	return calls
}
