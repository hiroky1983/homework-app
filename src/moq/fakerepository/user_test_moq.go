// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fakerepository

import (
	"homework/domain/model/user"
	"homework/domain/repository"
	"sync"
)

// Ensure, that IUserRepositoryMock does implement repository.IUserRepository.
// If this is not the case, regenerate this file with moq.
var _ repository.IUserRepository = &IUserRepositoryMock{}

// IUserRepositoryMock is a mock implementation of repository.IUserRepository.
//
//	func TestSomethingThatUsesIUserRepository(t *testing.T) {
//
//		// make and configure a mocked repository.IUserRepository
//		mockedIUserRepository := &IUserRepositoryMock{
//			CreateUserFunc: func(db repository.DBConn, userMoqParam *user.User) error {
//				panic("mock out the CreateUser method")
//			},
//			GetUserByEmailFunc: func(db repository.DBConn, userMoqParam *user.User, email string) error {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIDFunc: func(db repository.DBConn, userMoqParam *user.User, userID string) error {
//				panic("mock out the GetUserByID method")
//			},
//		}
//
//		// use mockedIUserRepository in code that requires repository.IUserRepository
//		// and then make assertions.
//
//	}
type IUserRepositoryMock struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(db repository.DBConn, userMoqParam *user.User) error

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(db repository.DBConn, userMoqParam *user.User, email string) error

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(db repository.DBConn, userMoqParam *user.User, userID string) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Db is the db argument value.
			Db repository.DBConn
			// UserMoqParam is the userMoqParam argument value.
			UserMoqParam *user.User
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Db is the db argument value.
			Db repository.DBConn
			// UserMoqParam is the userMoqParam argument value.
			UserMoqParam *user.User
			// Email is the email argument value.
			Email string
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Db is the db argument value.
			Db repository.DBConn
			// UserMoqParam is the userMoqParam argument value.
			UserMoqParam *user.User
			// UserID is the userID argument value.
			UserID string
		}
	}
	lockCreateUser     sync.RWMutex
	lockGetUserByEmail sync.RWMutex
	lockGetUserByID    sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *IUserRepositoryMock) CreateUser(db repository.DBConn, userMoqParam *user.User) error {
	if mock.CreateUserFunc == nil {
		panic("IUserRepositoryMock.CreateUserFunc: method is nil but IUserRepository.CreateUser was just called")
	}
	callInfo := struct {
		Db           repository.DBConn
		UserMoqParam *user.User
	}{
		Db:           db,
		UserMoqParam: userMoqParam,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(db, userMoqParam)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedIUserRepository.CreateUserCalls())
func (mock *IUserRepositoryMock) CreateUserCalls() []struct {
	Db           repository.DBConn
	UserMoqParam *user.User
} {
	var calls []struct {
		Db           repository.DBConn
		UserMoqParam *user.User
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *IUserRepositoryMock) GetUserByEmail(db repository.DBConn, userMoqParam *user.User, email string) error {
	if mock.GetUserByEmailFunc == nil {
		panic("IUserRepositoryMock.GetUserByEmailFunc: method is nil but IUserRepository.GetUserByEmail was just called")
	}
	callInfo := struct {
		Db           repository.DBConn
		UserMoqParam *user.User
		Email        string
	}{
		Db:           db,
		UserMoqParam: userMoqParam,
		Email:        email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(db, userMoqParam, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedIUserRepository.GetUserByEmailCalls())
func (mock *IUserRepositoryMock) GetUserByEmailCalls() []struct {
	Db           repository.DBConn
	UserMoqParam *user.User
	Email        string
} {
	var calls []struct {
		Db           repository.DBConn
		UserMoqParam *user.User
		Email        string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *IUserRepositoryMock) GetUserByID(db repository.DBConn, userMoqParam *user.User, userID string) error {
	if mock.GetUserByIDFunc == nil {
		panic("IUserRepositoryMock.GetUserByIDFunc: method is nil but IUserRepository.GetUserByID was just called")
	}
	callInfo := struct {
		Db           repository.DBConn
		UserMoqParam *user.User
		UserID       string
	}{
		Db:           db,
		UserMoqParam: userMoqParam,
		UserID:       userID,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(db, userMoqParam, userID)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedIUserRepository.GetUserByIDCalls())
func (mock *IUserRepositoryMock) GetUserByIDCalls() []struct {
	Db           repository.DBConn
	UserMoqParam *user.User
	UserID       string
} {
	var calls []struct {
		Db           repository.DBConn
		UserMoqParam *user.User
		UserID       string
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}
